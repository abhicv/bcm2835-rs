/* automatically generated by rust-bindgen 0.55.1 */

pub const BCM2835_VERSION: u32 = 10066;
pub const BCM2835_CORE_CLK_HZ: u32 = 250000000;
pub const BCM2835_PERI_BASE: u32 = 536870912;
pub const BCM2835_PERI_SIZE: u32 = 16777216;
pub const BCM2835_RPI2_PERI_BASE: u32 = 1056964608;
pub const BCM2835_RPI4_PERI_BASE: u32 = 4261412864;
pub const BCM2835_RPI4_PERI_SIZE: u32 = 25165824;
pub const BCM2835_ST_BASE: u32 = 12288;
pub const BCM2835_GPIO_PADS: u32 = 1048576;
pub const BCM2835_CLOCK_BASE: u32 = 1052672;
pub const BCM2835_GPIO_BASE: u32 = 2097152;
pub const BCM2835_SPI0_BASE: u32 = 2113536;
pub const BCM2835_BSC0_BASE: u32 = 2117632;
pub const BCM2835_GPIO_PWM: u32 = 2146304;
pub const BCM2835_AUX_BASE: u32 = 2183168;
pub const BCM2835_SPI1_BASE: u32 = 2183296;
pub const BCM2835_SPI2_BASE: u32 = 2183360;
pub const BCM2835_BSC1_BASE: u32 = 8404992;
pub const BCM2835_PAGE_SIZE: u32 = 4096;
pub const BCM2835_BLOCK_SIZE: u32 = 4096;
pub const BCM2835_GPFSEL0: u32 = 0;
pub const BCM2835_GPFSEL1: u32 = 4;
pub const BCM2835_GPFSEL2: u32 = 8;
pub const BCM2835_GPFSEL3: u32 = 12;
pub const BCM2835_GPFSEL4: u32 = 16;
pub const BCM2835_GPFSEL5: u32 = 20;
pub const BCM2835_GPSET0: u32 = 28;
pub const BCM2835_GPSET1: u32 = 32;
pub const BCM2835_GPCLR0: u32 = 40;
pub const BCM2835_GPCLR1: u32 = 44;
pub const BCM2835_GPLEV0: u32 = 52;
pub const BCM2835_GPLEV1: u32 = 56;
pub const BCM2835_GPEDS0: u32 = 64;
pub const BCM2835_GPEDS1: u32 = 68;
pub const BCM2835_GPREN0: u32 = 76;
pub const BCM2835_GPREN1: u32 = 80;
pub const BCM2835_GPFEN0: u32 = 88;
pub const BCM2835_GPFEN1: u32 = 92;
pub const BCM2835_GPHEN0: u32 = 100;
pub const BCM2835_GPHEN1: u32 = 104;
pub const BCM2835_GPLEN0: u32 = 112;
pub const BCM2835_GPLEN1: u32 = 116;
pub const BCM2835_GPAREN0: u32 = 124;
pub const BCM2835_GPAREN1: u32 = 128;
pub const BCM2835_GPAFEN0: u32 = 136;
pub const BCM2835_GPAFEN1: u32 = 140;
pub const BCM2835_GPPUD: u32 = 148;
pub const BCM2835_GPPUDCLK0: u32 = 152;
pub const BCM2835_GPPUDCLK1: u32 = 156;
pub const BCM2835_GPPUPPDN0: u32 = 228;
pub const BCM2835_GPPUPPDN1: u32 = 232;
pub const BCM2835_GPPUPPDN2: u32 = 236;
pub const BCM2835_GPPUPPDN3: u32 = 240;
pub const BCM2835_GPIO_PUD_ERROR: u32 = 8;
pub const BCM2835_PADS_GPIO_0_27: u32 = 44;
pub const BCM2835_PADS_GPIO_28_45: u32 = 48;
pub const BCM2835_PADS_GPIO_46_53: u32 = 52;
pub const BCM2835_PAD_PASSWRD: u32 = 1509949440;
pub const BCM2835_PAD_SLEW_RATE_UNLIMITED: u32 = 16;
pub const BCM2835_PAD_HYSTERESIS_ENABLED: u32 = 8;
pub const BCM2835_PAD_DRIVE_2mA: u32 = 0;
pub const BCM2835_PAD_DRIVE_4mA: u32 = 1;
pub const BCM2835_PAD_DRIVE_6mA: u32 = 2;
pub const BCM2835_PAD_DRIVE_8mA: u32 = 3;
pub const BCM2835_PAD_DRIVE_10mA: u32 = 4;
pub const BCM2835_PAD_DRIVE_12mA: u32 = 5;
pub const BCM2835_PAD_DRIVE_14mA: u32 = 6;
pub const BCM2835_PAD_DRIVE_16mA: u32 = 7;
pub const BCM2835_AUX_IRQ: u32 = 0;
pub const BCM2835_AUX_ENABLE: u32 = 4;
pub const BCM2835_AUX_ENABLE_UART1: u32 = 1;
pub const BCM2835_AUX_ENABLE_SPI0: u32 = 2;
pub const BCM2835_AUX_ENABLE_SPI1: u32 = 4;
pub const BCM2835_AUX_SPI_CNTL0: u32 = 0;
pub const BCM2835_AUX_SPI_CNTL1: u32 = 4;
pub const BCM2835_AUX_SPI_STAT: u32 = 8;
pub const BCM2835_AUX_SPI_PEEK: u32 = 12;
pub const BCM2835_AUX_SPI_IO: u32 = 32;
pub const BCM2835_AUX_SPI_TXHOLD: u32 = 48;
pub const BCM2835_AUX_SPI_CLOCK_MIN: u32 = 30500;
pub const BCM2835_AUX_SPI_CLOCK_MAX: u32 = 125000000;
pub const BCM2835_AUX_SPI_CNTL0_SPEED: u32 = 4293918720;
pub const BCM2835_AUX_SPI_CNTL0_SPEED_MAX: u32 = 4095;
pub const BCM2835_AUX_SPI_CNTL0_SPEED_SHIFT: u32 = 20;
pub const BCM2835_AUX_SPI_CNTL0_CS0_N: u32 = 786432;
pub const BCM2835_AUX_SPI_CNTL0_CS1_N: u32 = 655360;
pub const BCM2835_AUX_SPI_CNTL0_CS2_N: u32 = 393216;
pub const BCM2835_AUX_SPI_CNTL0_POSTINPUT: u32 = 65536;
pub const BCM2835_AUX_SPI_CNTL0_VAR_CS: u32 = 32768;
pub const BCM2835_AUX_SPI_CNTL0_VAR_WIDTH: u32 = 16384;
pub const BCM2835_AUX_SPI_CNTL0_DOUTHOLD: u32 = 12288;
pub const BCM2835_AUX_SPI_CNTL0_ENABLE: u32 = 2048;
pub const BCM2835_AUX_SPI_CNTL0_CPHA_IN: u32 = 1024;
pub const BCM2835_AUX_SPI_CNTL0_CLEARFIFO: u32 = 512;
pub const BCM2835_AUX_SPI_CNTL0_CPHA_OUT: u32 = 256;
pub const BCM2835_AUX_SPI_CNTL0_CPOL: u32 = 128;
pub const BCM2835_AUX_SPI_CNTL0_MSBF_OUT: u32 = 64;
pub const BCM2835_AUX_SPI_CNTL0_SHIFTLEN: u32 = 63;
pub const BCM2835_AUX_SPI_CNTL1_CSHIGH: u32 = 1792;
pub const BCM2835_AUX_SPI_CNTL1_IDLE: u32 = 128;
pub const BCM2835_AUX_SPI_CNTL1_TXEMPTY: u32 = 64;
pub const BCM2835_AUX_SPI_CNTL1_MSBF_IN: u32 = 2;
pub const BCM2835_AUX_SPI_CNTL1_KEEP_IN: u32 = 1;
pub const BCM2835_AUX_SPI_STAT_TX_LVL: u32 = 4026531840;
pub const BCM2835_AUX_SPI_STAT_RX_LVL: u32 = 15728640;
pub const BCM2835_AUX_SPI_STAT_TX_FULL: u32 = 1024;
pub const BCM2835_AUX_SPI_STAT_TX_EMPTY: u32 = 512;
pub const BCM2835_AUX_SPI_STAT_RX_FULL: u32 = 256;
pub const BCM2835_AUX_SPI_STAT_RX_EMPTY: u32 = 128;
pub const BCM2835_AUX_SPI_STAT_BUSY: u32 = 64;
pub const BCM2835_AUX_SPI_STAT_BITCOUNT: u32 = 63;
pub const BCM2835_SPI0_CS: u32 = 0;
pub const BCM2835_SPI0_FIFO: u32 = 4;
pub const BCM2835_SPI0_CLK: u32 = 8;
pub const BCM2835_SPI0_DLEN: u32 = 12;
pub const BCM2835_SPI0_LTOH: u32 = 16;
pub const BCM2835_SPI0_DC: u32 = 20;
pub const BCM2835_SPI0_CS_LEN_LONG: u32 = 33554432;
pub const BCM2835_SPI0_CS_DMA_LEN: u32 = 16777216;
pub const BCM2835_SPI0_CS_CSPOL2: u32 = 8388608;
pub const BCM2835_SPI0_CS_CSPOL1: u32 = 4194304;
pub const BCM2835_SPI0_CS_CSPOL0: u32 = 2097152;
pub const BCM2835_SPI0_CS_RXF: u32 = 1048576;
pub const BCM2835_SPI0_CS_RXR: u32 = 524288;
pub const BCM2835_SPI0_CS_TXD: u32 = 262144;
pub const BCM2835_SPI0_CS_RXD: u32 = 131072;
pub const BCM2835_SPI0_CS_DONE: u32 = 65536;
pub const BCM2835_SPI0_CS_TE_EN: u32 = 32768;
pub const BCM2835_SPI0_CS_LMONO: u32 = 16384;
pub const BCM2835_SPI0_CS_LEN: u32 = 8192;
pub const BCM2835_SPI0_CS_REN: u32 = 4096;
pub const BCM2835_SPI0_CS_ADCS: u32 = 2048;
pub const BCM2835_SPI0_CS_INTR: u32 = 1024;
pub const BCM2835_SPI0_CS_INTD: u32 = 512;
pub const BCM2835_SPI0_CS_DMAEN: u32 = 256;
pub const BCM2835_SPI0_CS_TA: u32 = 128;
pub const BCM2835_SPI0_CS_CSPOL: u32 = 64;
pub const BCM2835_SPI0_CS_CLEAR: u32 = 48;
pub const BCM2835_SPI0_CS_CLEAR_RX: u32 = 32;
pub const BCM2835_SPI0_CS_CLEAR_TX: u32 = 16;
pub const BCM2835_SPI0_CS_CPOL: u32 = 8;
pub const BCM2835_SPI0_CS_CPHA: u32 = 4;
pub const BCM2835_SPI0_CS_CS: u32 = 3;
pub const BCM2835_BSC_C: u32 = 0;
pub const BCM2835_BSC_S: u32 = 4;
pub const BCM2835_BSC_DLEN: u32 = 8;
pub const BCM2835_BSC_A: u32 = 12;
pub const BCM2835_BSC_FIFO: u32 = 16;
pub const BCM2835_BSC_DIV: u32 = 20;
pub const BCM2835_BSC_DEL: u32 = 24;
pub const BCM2835_BSC_CLKT: u32 = 28;
pub const BCM2835_BSC_C_I2CEN: u32 = 32768;
pub const BCM2835_BSC_C_INTR: u32 = 1024;
pub const BCM2835_BSC_C_INTT: u32 = 512;
pub const BCM2835_BSC_C_INTD: u32 = 256;
pub const BCM2835_BSC_C_ST: u32 = 128;
pub const BCM2835_BSC_C_CLEAR_1: u32 = 32;
pub const BCM2835_BSC_C_CLEAR_2: u32 = 16;
pub const BCM2835_BSC_C_READ: u32 = 1;
pub const BCM2835_BSC_S_CLKT: u32 = 512;
pub const BCM2835_BSC_S_ERR: u32 = 256;
pub const BCM2835_BSC_S_RXF: u32 = 128;
pub const BCM2835_BSC_S_TXE: u32 = 64;
pub const BCM2835_BSC_S_RXD: u32 = 32;
pub const BCM2835_BSC_S_TXD: u32 = 16;
pub const BCM2835_BSC_S_RXR: u32 = 8;
pub const BCM2835_BSC_S_TXW: u32 = 4;
pub const BCM2835_BSC_S_DONE: u32 = 2;
pub const BCM2835_BSC_S_TA: u32 = 1;
pub const BCM2835_BSC_FIFO_SIZE: u32 = 16;
pub const BCM2835_ST_CS: u32 = 0;
pub const BCM2835_ST_CLO: u32 = 4;
pub const BCM2835_ST_CHI: u32 = 8;
pub const BCM2835_PWM_CONTROL: u32 = 0;
pub const BCM2835_PWM_STATUS: u32 = 1;
pub const BCM2835_PWM_DMAC: u32 = 2;
pub const BCM2835_PWM0_RANGE: u32 = 4;
pub const BCM2835_PWM0_DATA: u32 = 5;
pub const BCM2835_PWM_FIF1: u32 = 6;
pub const BCM2835_PWM1_RANGE: u32 = 8;
pub const BCM2835_PWM1_DATA: u32 = 9;
pub const BCM2835_PWMCLK_CNTL: u32 = 40;
pub const BCM2835_PWMCLK_DIV: u32 = 41;
pub const BCM2835_PWM_PASSWRD: u32 = 1509949440;
pub const BCM2835_PWM1_MS_MODE: u32 = 32768;
pub const BCM2835_PWM1_USEFIFO: u32 = 8192;
pub const BCM2835_PWM1_REVPOLAR: u32 = 4096;
pub const BCM2835_PWM1_OFFSTATE: u32 = 2048;
pub const BCM2835_PWM1_REPEATFF: u32 = 1024;
pub const BCM2835_PWM1_SERIAL: u32 = 512;
pub const BCM2835_PWM1_ENABLE: u32 = 256;
pub const BCM2835_PWM0_MS_MODE: u32 = 128;
pub const BCM2835_PWM_CLEAR_FIFO: u32 = 64;
pub const BCM2835_PWM0_USEFIFO: u32 = 32;
pub const BCM2835_PWM0_REVPOLAR: u32 = 16;
pub const BCM2835_PWM0_OFFSTATE: u32 = 8;
pub const BCM2835_PWM0_REPEATFF: u32 = 4;
pub const BCM2835_PWM0_SERIAL: u32 = 2;
pub const BCM2835_PWM0_ENABLE: u32 = 1;
pub type size_t = ::std::os::raw::c_ulonglong;
extern "C" {
    pub static mut bcm2835_peripherals_base: ::std::os::raw::c_ulong;
}
extern "C" {
    pub static mut bcm2835_peripherals_size: size_t;
}
extern "C" {
    pub static mut bcm2835_peripherals: *mut u32;
}
extern "C" {
    pub static mut bcm2835_st: *mut u32;
}
extern "C" {
    pub static mut bcm2835_gpio: *mut u32;
}
extern "C" {
    pub static mut bcm2835_pwm: *mut u32;
}
extern "C" {
    pub static mut bcm2835_clk: *mut u32;
}
extern "C" {
    pub static mut bcm2835_pads: *mut u32;
}
extern "C" {
    pub static mut bcm2835_spi0: *mut u32;
}
extern "C" {
    pub static mut bcm2835_bsc0: *mut u32;
}
extern "C" {
    pub static mut bcm2835_bsc1: *mut u32;
}
extern "C" {
    pub static mut bcm2835_aux: *mut u32;
}
extern "C" {
    pub static mut bcm2835_spi1: *mut u32;
}
#[doc = "< Base of the ST (System Timer) registers."]
pub const bcm2835RegisterBase_BCM2835_REGBASE_ST: bcm2835RegisterBase = 1;
#[doc = "< Base of the GPIO registers."]
pub const bcm2835RegisterBase_BCM2835_REGBASE_GPIO: bcm2835RegisterBase = 2;
#[doc = "< Base of the PWM registers."]
pub const bcm2835RegisterBase_BCM2835_REGBASE_PWM: bcm2835RegisterBase = 3;
#[doc = "< Base of the CLK registers."]
pub const bcm2835RegisterBase_BCM2835_REGBASE_CLK: bcm2835RegisterBase = 4;
#[doc = "< Base of the PADS registers."]
pub const bcm2835RegisterBase_BCM2835_REGBASE_PADS: bcm2835RegisterBase = 5;
#[doc = "< Base of the SPI0 registers."]
pub const bcm2835RegisterBase_BCM2835_REGBASE_SPI0: bcm2835RegisterBase = 6;
#[doc = "< Base of the BSC0 registers."]
pub const bcm2835RegisterBase_BCM2835_REGBASE_BSC0: bcm2835RegisterBase = 7;
#[doc = "< Base of the BSC1 registers."]
pub const bcm2835RegisterBase_BCM2835_REGBASE_BSC1: bcm2835RegisterBase = 8;
#[doc = "< Base of the AUX registers."]
pub const bcm2835RegisterBase_BCM2835_REGBASE_AUX: bcm2835RegisterBase = 9;
#[doc = "< Base of the SPI1 registers."]
pub const bcm2835RegisterBase_BCM2835_REGBASE_SPI1: bcm2835RegisterBase = 10;
#[doc = " \\brief bcm2835RegisterBase"]
#[doc = "Register bases for bcm2835_regbase()"]
pub type bcm2835RegisterBase = ::std::os::raw::c_uint;
#[doc = "< Input 0b000"]
pub const bcm2835FunctionSelect_BCM2835_GPIO_FSEL_INPT: bcm2835FunctionSelect = 0;
#[doc = "< Output 0b001"]
pub const bcm2835FunctionSelect_BCM2835_GPIO_FSEL_OUTP: bcm2835FunctionSelect = 1;
#[doc = "< Alternate function 0 0b100"]
pub const bcm2835FunctionSelect_BCM2835_GPIO_FSEL_ALT0: bcm2835FunctionSelect = 4;
#[doc = "< Alternate function 1 0b101"]
pub const bcm2835FunctionSelect_BCM2835_GPIO_FSEL_ALT1: bcm2835FunctionSelect = 5;
#[doc = "< Alternate function 2 0b110,"]
pub const bcm2835FunctionSelect_BCM2835_GPIO_FSEL_ALT2: bcm2835FunctionSelect = 6;
#[doc = "< Alternate function 3 0b111"]
pub const bcm2835FunctionSelect_BCM2835_GPIO_FSEL_ALT3: bcm2835FunctionSelect = 7;
#[doc = "< Alternate function 4 0b011"]
pub const bcm2835FunctionSelect_BCM2835_GPIO_FSEL_ALT4: bcm2835FunctionSelect = 3;
#[doc = "< Alternate function 5 0b010"]
pub const bcm2835FunctionSelect_BCM2835_GPIO_FSEL_ALT5: bcm2835FunctionSelect = 2;
#[doc = "< Function select bits mask 0b111"]
pub const bcm2835FunctionSelect_BCM2835_GPIO_FSEL_MASK: bcm2835FunctionSelect = 7;
#[doc = "   \\brief bcm2835PortFunction"]
#[doc = "Port function select modes for bcm2835_gpio_fsel()"]
pub type bcm2835FunctionSelect = ::std::os::raw::c_uint;
#[doc = "< Off ? disable pull-up/down 0b00"]
pub const bcm2835PUDControl_BCM2835_GPIO_PUD_OFF: bcm2835PUDControl = 0;
#[doc = "< Enable Pull Down control 0b01"]
pub const bcm2835PUDControl_BCM2835_GPIO_PUD_DOWN: bcm2835PUDControl = 1;
#[doc = "< Enable Pull Up control 0b10"]
pub const bcm2835PUDControl_BCM2835_GPIO_PUD_UP: bcm2835PUDControl = 2;
#[doc = " \\brief bcm2835PUDControl"]
#[doc = "Pullup/Pulldown defines for bcm2835_gpio_pud()"]
pub type bcm2835PUDControl = ::std::os::raw::c_uint;
#[doc = "< Pad group for GPIO pads 0 to 27"]
pub const bcm2835PadGroup_BCM2835_PAD_GROUP_GPIO_0_27: bcm2835PadGroup = 0;
#[doc = "< Pad group for GPIO pads 28 to 45"]
pub const bcm2835PadGroup_BCM2835_PAD_GROUP_GPIO_28_45: bcm2835PadGroup = 1;
#[doc = "< Pad group for GPIO pads 46 to 53"]
pub const bcm2835PadGroup_BCM2835_PAD_GROUP_GPIO_46_53: bcm2835PadGroup = 2;
#[doc = " \\brief bcm2835PadGroup"]
#[doc = "Pad group specification for bcm2835_gpio_pad()"]
pub type bcm2835PadGroup = ::std::os::raw::c_uint;
#[doc = "< Version 1, Pin P1-03"]
pub const RPiGPIOPin_RPI_GPIO_P1_03: RPiGPIOPin = 0;
#[doc = "< Version 1, Pin P1-05"]
pub const RPiGPIOPin_RPI_GPIO_P1_05: RPiGPIOPin = 1;
#[doc = "< Version 1, Pin P1-07"]
pub const RPiGPIOPin_RPI_GPIO_P1_07: RPiGPIOPin = 4;
#[doc = "< Version 1, Pin P1-08, defaults to alt function 0 UART0_TXD"]
pub const RPiGPIOPin_RPI_GPIO_P1_08: RPiGPIOPin = 14;
#[doc = "< Version 1, Pin P1-10, defaults to alt function 0 UART0_RXD"]
pub const RPiGPIOPin_RPI_GPIO_P1_10: RPiGPIOPin = 15;
#[doc = "< Version 1, Pin P1-11"]
pub const RPiGPIOPin_RPI_GPIO_P1_11: RPiGPIOPin = 17;
#[doc = "< Version 1, Pin P1-12, can be PWM channel 0 in ALT FUN 5"]
pub const RPiGPIOPin_RPI_GPIO_P1_12: RPiGPIOPin = 18;
#[doc = "< Version 1, Pin P1-13"]
pub const RPiGPIOPin_RPI_GPIO_P1_13: RPiGPIOPin = 21;
#[doc = "< Version 1, Pin P1-15"]
pub const RPiGPIOPin_RPI_GPIO_P1_15: RPiGPIOPin = 22;
#[doc = "< Version 1, Pin P1-16"]
pub const RPiGPIOPin_RPI_GPIO_P1_16: RPiGPIOPin = 23;
#[doc = "< Version 1, Pin P1-18"]
pub const RPiGPIOPin_RPI_GPIO_P1_18: RPiGPIOPin = 24;
#[doc = "< Version 1, Pin P1-19, MOSI when SPI0 in use"]
pub const RPiGPIOPin_RPI_GPIO_P1_19: RPiGPIOPin = 10;
#[doc = "< Version 1, Pin P1-21, MISO when SPI0 in use"]
pub const RPiGPIOPin_RPI_GPIO_P1_21: RPiGPIOPin = 9;
#[doc = "< Version 1, Pin P1-22"]
pub const RPiGPIOPin_RPI_GPIO_P1_22: RPiGPIOPin = 25;
#[doc = "< Version 1, Pin P1-23, CLK when SPI0 in use"]
pub const RPiGPIOPin_RPI_GPIO_P1_23: RPiGPIOPin = 11;
#[doc = "< Version 1, Pin P1-24, CE0 when SPI0 in use"]
pub const RPiGPIOPin_RPI_GPIO_P1_24: RPiGPIOPin = 8;
#[doc = "< Version 1, Pin P1-26, CE1 when SPI0 in use"]
pub const RPiGPIOPin_RPI_GPIO_P1_26: RPiGPIOPin = 7;
#[doc = "< Version 2, Pin P1-03"]
pub const RPiGPIOPin_RPI_V2_GPIO_P1_03: RPiGPIOPin = 2;
#[doc = "< Version 2, Pin P1-05"]
pub const RPiGPIOPin_RPI_V2_GPIO_P1_05: RPiGPIOPin = 3;
#[doc = "< Version 2, Pin P1-07"]
pub const RPiGPIOPin_RPI_V2_GPIO_P1_07: RPiGPIOPin = 4;
#[doc = "< Version 2, Pin P1-08, defaults to alt function 0 UART0_TXD"]
pub const RPiGPIOPin_RPI_V2_GPIO_P1_08: RPiGPIOPin = 14;
#[doc = "< Version 2, Pin P1-10, defaults to alt function 0 UART0_RXD"]
pub const RPiGPIOPin_RPI_V2_GPIO_P1_10: RPiGPIOPin = 15;
#[doc = "< Version 2, Pin P1-11"]
pub const RPiGPIOPin_RPI_V2_GPIO_P1_11: RPiGPIOPin = 17;
#[doc = "< Version 2, Pin P1-12, can be PWM channel 0 in ALT FUN 5"]
pub const RPiGPIOPin_RPI_V2_GPIO_P1_12: RPiGPIOPin = 18;
#[doc = "< Version 2, Pin P1-13"]
pub const RPiGPIOPin_RPI_V2_GPIO_P1_13: RPiGPIOPin = 27;
#[doc = "< Version 2, Pin P1-15"]
pub const RPiGPIOPin_RPI_V2_GPIO_P1_15: RPiGPIOPin = 22;
#[doc = "< Version 2, Pin P1-16"]
pub const RPiGPIOPin_RPI_V2_GPIO_P1_16: RPiGPIOPin = 23;
#[doc = "< Version 2, Pin P1-18"]
pub const RPiGPIOPin_RPI_V2_GPIO_P1_18: RPiGPIOPin = 24;
#[doc = "< Version 2, Pin P1-19, MOSI when SPI0 in use"]
pub const RPiGPIOPin_RPI_V2_GPIO_P1_19: RPiGPIOPin = 10;
#[doc = "< Version 2, Pin P1-21, MISO when SPI0 in use"]
pub const RPiGPIOPin_RPI_V2_GPIO_P1_21: RPiGPIOPin = 9;
#[doc = "< Version 2, Pin P1-22"]
pub const RPiGPIOPin_RPI_V2_GPIO_P1_22: RPiGPIOPin = 25;
#[doc = "< Version 2, Pin P1-23, CLK when SPI0 in use"]
pub const RPiGPIOPin_RPI_V2_GPIO_P1_23: RPiGPIOPin = 11;
#[doc = "< Version 2, Pin P1-24, CE0 when SPI0 in use"]
pub const RPiGPIOPin_RPI_V2_GPIO_P1_24: RPiGPIOPin = 8;
#[doc = "< Version 2, Pin P1-26, CE1 when SPI0 in use"]
pub const RPiGPIOPin_RPI_V2_GPIO_P1_26: RPiGPIOPin = 7;
#[doc = "< Version 2, Pin P1-29"]
pub const RPiGPIOPin_RPI_V2_GPIO_P1_29: RPiGPIOPin = 5;
#[doc = "< Version 2, Pin P1-31"]
pub const RPiGPIOPin_RPI_V2_GPIO_P1_31: RPiGPIOPin = 6;
#[doc = "< Version 2, Pin P1-32"]
pub const RPiGPIOPin_RPI_V2_GPIO_P1_32: RPiGPIOPin = 12;
#[doc = "< Version 2, Pin P1-33"]
pub const RPiGPIOPin_RPI_V2_GPIO_P1_33: RPiGPIOPin = 13;
#[doc = "< Version 2, Pin P1-35, can be PWM channel 1 in ALT FUN 5"]
pub const RPiGPIOPin_RPI_V2_GPIO_P1_35: RPiGPIOPin = 19;
#[doc = "< Version 2, Pin P1-36"]
pub const RPiGPIOPin_RPI_V2_GPIO_P1_36: RPiGPIOPin = 16;
#[doc = "< Version 2, Pin P1-37"]
pub const RPiGPIOPin_RPI_V2_GPIO_P1_37: RPiGPIOPin = 26;
#[doc = "< Version 2, Pin P1-38"]
pub const RPiGPIOPin_RPI_V2_GPIO_P1_38: RPiGPIOPin = 20;
#[doc = "< Version 2, Pin P1-40"]
pub const RPiGPIOPin_RPI_V2_GPIO_P1_40: RPiGPIOPin = 21;
#[doc = "< Version 2, Pin P5-03"]
pub const RPiGPIOPin_RPI_V2_GPIO_P5_03: RPiGPIOPin = 28;
#[doc = "< Version 2, Pin P5-04"]
pub const RPiGPIOPin_RPI_V2_GPIO_P5_04: RPiGPIOPin = 29;
#[doc = "< Version 2, Pin P5-05"]
pub const RPiGPIOPin_RPI_V2_GPIO_P5_05: RPiGPIOPin = 30;
#[doc = "< Version 2, Pin P5-06"]
pub const RPiGPIOPin_RPI_V2_GPIO_P5_06: RPiGPIOPin = 31;
#[doc = "< B+, Pin J8-03"]
pub const RPiGPIOPin_RPI_BPLUS_GPIO_J8_03: RPiGPIOPin = 2;
#[doc = "< B+, Pin J8-05"]
pub const RPiGPIOPin_RPI_BPLUS_GPIO_J8_05: RPiGPIOPin = 3;
#[doc = "< B+, Pin J8-07"]
pub const RPiGPIOPin_RPI_BPLUS_GPIO_J8_07: RPiGPIOPin = 4;
#[doc = "< B+, Pin J8-08, defaults to alt function 0 UART0_TXD"]
pub const RPiGPIOPin_RPI_BPLUS_GPIO_J8_08: RPiGPIOPin = 14;
#[doc = "< B+, Pin J8-10, defaults to alt function 0 UART0_RXD"]
pub const RPiGPIOPin_RPI_BPLUS_GPIO_J8_10: RPiGPIOPin = 15;
#[doc = "< B+, Pin J8-11"]
pub const RPiGPIOPin_RPI_BPLUS_GPIO_J8_11: RPiGPIOPin = 17;
#[doc = "< B+, Pin J8-12, can be PWM channel 0 in ALT FUN 5"]
pub const RPiGPIOPin_RPI_BPLUS_GPIO_J8_12: RPiGPIOPin = 18;
#[doc = "< B+, Pin J8-13"]
pub const RPiGPIOPin_RPI_BPLUS_GPIO_J8_13: RPiGPIOPin = 27;
#[doc = "< B+, Pin J8-15"]
pub const RPiGPIOPin_RPI_BPLUS_GPIO_J8_15: RPiGPIOPin = 22;
#[doc = "< B+, Pin J8-16"]
pub const RPiGPIOPin_RPI_BPLUS_GPIO_J8_16: RPiGPIOPin = 23;
#[doc = "< B+, Pin J8-18"]
pub const RPiGPIOPin_RPI_BPLUS_GPIO_J8_18: RPiGPIOPin = 24;
#[doc = "< B+, Pin J8-19, MOSI when SPI0 in use"]
pub const RPiGPIOPin_RPI_BPLUS_GPIO_J8_19: RPiGPIOPin = 10;
#[doc = "< B+, Pin J8-21, MISO when SPI0 in use"]
pub const RPiGPIOPin_RPI_BPLUS_GPIO_J8_21: RPiGPIOPin = 9;
#[doc = "< B+, Pin J8-22"]
pub const RPiGPIOPin_RPI_BPLUS_GPIO_J8_22: RPiGPIOPin = 25;
#[doc = "< B+, Pin J8-23, CLK when SPI0 in use"]
pub const RPiGPIOPin_RPI_BPLUS_GPIO_J8_23: RPiGPIOPin = 11;
#[doc = "< B+, Pin J8-24, CE0 when SPI0 in use"]
pub const RPiGPIOPin_RPI_BPLUS_GPIO_J8_24: RPiGPIOPin = 8;
#[doc = "< B+, Pin J8-26, CE1 when SPI0 in use"]
pub const RPiGPIOPin_RPI_BPLUS_GPIO_J8_26: RPiGPIOPin = 7;
#[doc = "< B+, Pin J8-29,"]
pub const RPiGPIOPin_RPI_BPLUS_GPIO_J8_29: RPiGPIOPin = 5;
#[doc = "< B+, Pin J8-31,"]
pub const RPiGPIOPin_RPI_BPLUS_GPIO_J8_31: RPiGPIOPin = 6;
#[doc = "< B+, Pin J8-32,"]
pub const RPiGPIOPin_RPI_BPLUS_GPIO_J8_32: RPiGPIOPin = 12;
#[doc = "< B+, Pin J8-33,"]
pub const RPiGPIOPin_RPI_BPLUS_GPIO_J8_33: RPiGPIOPin = 13;
#[doc = "< B+, Pin J8-35, can be PWM channel 1 in ALT FUN 5"]
pub const RPiGPIOPin_RPI_BPLUS_GPIO_J8_35: RPiGPIOPin = 19;
#[doc = "< B+, Pin J8-36,"]
pub const RPiGPIOPin_RPI_BPLUS_GPIO_J8_36: RPiGPIOPin = 16;
#[doc = "< B+, Pin J8-37,"]
pub const RPiGPIOPin_RPI_BPLUS_GPIO_J8_37: RPiGPIOPin = 26;
#[doc = "< B+, Pin J8-38,"]
pub const RPiGPIOPin_RPI_BPLUS_GPIO_J8_38: RPiGPIOPin = 20;
#[doc = "< B+, Pin J8-40,"]
pub const RPiGPIOPin_RPI_BPLUS_GPIO_J8_40: RPiGPIOPin = 21;
#[doc = " \\brief GPIO Pin Numbers"]
#[doc = ""]
#[doc = "Here we define Raspberry Pin GPIO pins on P1 in terms of the underlying BCM GPIO pin numbers."]
#[doc = "These can be passed as a pin number to any function requiring a pin."]
#[doc = "Not all pins on the RPi 26 bin IDE plug are connected to GPIO pins"]
#[doc = "and some can adopt an alternate function."]
#[doc = "RPi version 2 has some slightly different pinouts, and these are values RPI_V2_*."]
#[doc = "RPi B+ has yet differnet pinouts and these are defined in RPI_BPLUS_*."]
#[doc = "At bootup, pins 8 and 10 are set to UART0_TXD, UART0_RXD (ie the alt0 function) respectively"]
#[doc = "When SPI0 is in use (ie after bcm2835_spi_begin()), SPI0 pins are dedicated to SPI"]
#[doc = "and cant be controlled independently."]
#[doc = "If you are using the RPi Compute Module, just use the GPIO number: there is no need to use one of these"]
#[doc = "symbolic names"]
pub type RPiGPIOPin = ::std::os::raw::c_uint;

#[doc = "< LSB First"]
pub const bcm2835SPIBitOrder_BCM2835_SPI_BIT_ORDER_LSBFIRST: bcm2835SPIBitOrder = 0;
#[doc = "< MSB First"]
pub const bcm2835SPIBitOrder_BCM2835_SPI_BIT_ORDER_MSBFIRST: bcm2835SPIBitOrder = 1;
#[doc = " \\brief bcm2835SPIBitOrder SPI Bit order"]
#[doc = "Specifies the SPI data bit ordering for bcm2835_spi_setBitOrder()"]
pub type bcm2835SPIBitOrder = ::std::os::raw::c_uint;
#[doc = "< CPOL = 0, CPHA = 0"]
pub const bcm2835SPIMode_BCM2835_SPI_MODE0: bcm2835SPIMode = 0;
#[doc = "< CPOL = 0, CPHA = 1"]
pub const bcm2835SPIMode_BCM2835_SPI_MODE1: bcm2835SPIMode = 1;
#[doc = "< CPOL = 1, CPHA = 0"]
pub const bcm2835SPIMode_BCM2835_SPI_MODE2: bcm2835SPIMode = 2;
#[doc = "< CPOL = 1, CPHA = 1"]
pub const bcm2835SPIMode_BCM2835_SPI_MODE3: bcm2835SPIMode = 3;
#[doc = " \\brief SPI Data mode"]
#[doc = "Specify the SPI data mode to be passed to bcm2835_spi_setDataMode()"]
pub type bcm2835SPIMode = ::std::os::raw::c_uint;
#[doc = "< Chip Select 0"]
pub const bcm2835SPIChipSelect_BCM2835_SPI_CS0: bcm2835SPIChipSelect = 0;
#[doc = "< Chip Select 1"]
pub const bcm2835SPIChipSelect_BCM2835_SPI_CS1: bcm2835SPIChipSelect = 1;
#[doc = "< Chip Select 2 (ie pins CS1 and CS2 are asserted)"]
pub const bcm2835SPIChipSelect_BCM2835_SPI_CS2: bcm2835SPIChipSelect = 2;
#[doc = "< No CS, control it yourself"]
pub const bcm2835SPIChipSelect_BCM2835_SPI_CS_NONE: bcm2835SPIChipSelect = 3;
#[doc = " \\brief bcm2835SPIChipSelect"]
#[doc = "Specify the SPI chip select pin(s)"]
pub type bcm2835SPIChipSelect = ::std::os::raw::c_uint;
#[doc = "< 65536 = 3.814697260kHz on Rpi2, 6.1035156kHz on RPI3"]
pub const bcm2835SPIClockDivider_BCM2835_SPI_CLOCK_DIVIDER_65536: bcm2835SPIClockDivider = 0;
#[doc = "< 32768 = 7.629394531kHz on Rpi2, 12.20703125kHz on RPI3"]
pub const bcm2835SPIClockDivider_BCM2835_SPI_CLOCK_DIVIDER_32768: bcm2835SPIClockDivider = 32768;
#[doc = "< 16384 = 15.25878906kHz on Rpi2, 24.4140625kHz on RPI3"]
pub const bcm2835SPIClockDivider_BCM2835_SPI_CLOCK_DIVIDER_16384: bcm2835SPIClockDivider = 16384;
#[doc = "< 8192 = 30.51757813kHz on Rpi2, 48.828125kHz on RPI3"]
pub const bcm2835SPIClockDivider_BCM2835_SPI_CLOCK_DIVIDER_8192: bcm2835SPIClockDivider = 8192;
#[doc = "< 4096 = 61.03515625kHz on Rpi2, 97.65625kHz on RPI3"]
pub const bcm2835SPIClockDivider_BCM2835_SPI_CLOCK_DIVIDER_4096: bcm2835SPIClockDivider = 4096;
#[doc = "< 2048 = 122.0703125kHz on Rpi2, 195.3125kHz on RPI3"]
pub const bcm2835SPIClockDivider_BCM2835_SPI_CLOCK_DIVIDER_2048: bcm2835SPIClockDivider = 2048;
#[doc = "< 1024 = 244.140625kHz on Rpi2, 390.625kHz on RPI3"]
pub const bcm2835SPIClockDivider_BCM2835_SPI_CLOCK_DIVIDER_1024: bcm2835SPIClockDivider = 1024;
#[doc = "< 512 = 488.28125kHz on Rpi2, 781.25kHz on RPI3"]
pub const bcm2835SPIClockDivider_BCM2835_SPI_CLOCK_DIVIDER_512: bcm2835SPIClockDivider = 512;
#[doc = "< 256 = 976.5625kHz on Rpi2, 1.5625MHz on RPI3"]
pub const bcm2835SPIClockDivider_BCM2835_SPI_CLOCK_DIVIDER_256: bcm2835SPIClockDivider = 256;
#[doc = "< 128 = 1.953125MHz on Rpi2, 3.125MHz on RPI3"]
pub const bcm2835SPIClockDivider_BCM2835_SPI_CLOCK_DIVIDER_128: bcm2835SPIClockDivider = 128;
#[doc = "< 64 = 3.90625MHz on Rpi2, 6.250MHz on RPI3"]
pub const bcm2835SPIClockDivider_BCM2835_SPI_CLOCK_DIVIDER_64: bcm2835SPIClockDivider = 64;
#[doc = "< 32 = 7.8125MHz on Rpi2, 12.5MHz on RPI3"]
pub const bcm2835SPIClockDivider_BCM2835_SPI_CLOCK_DIVIDER_32: bcm2835SPIClockDivider = 32;
#[doc = "< 16 = 15.625MHz on Rpi2, 25MHz on RPI3"]
pub const bcm2835SPIClockDivider_BCM2835_SPI_CLOCK_DIVIDER_16: bcm2835SPIClockDivider = 16;
#[doc = "< 8 = 31.25MHz on Rpi2, 50MHz on RPI3"]
pub const bcm2835SPIClockDivider_BCM2835_SPI_CLOCK_DIVIDER_8: bcm2835SPIClockDivider = 8;
#[doc = "< 4 = 62.5MHz on Rpi2, 100MHz on RPI3. Dont expect this speed to work reliably."]
pub const bcm2835SPIClockDivider_BCM2835_SPI_CLOCK_DIVIDER_4: bcm2835SPIClockDivider = 4;
#[doc = "< 2 = 125MHz on Rpi2, 200MHz on RPI3, fastest you can get. Dont expect this speed to work reliably."]
pub const bcm2835SPIClockDivider_BCM2835_SPI_CLOCK_DIVIDER_2: bcm2835SPIClockDivider = 2;
#[doc = "< 1 = 3.814697260kHz on Rpi2, 6.1035156kHz on RPI3, same as 0/65536"]
pub const bcm2835SPIClockDivider_BCM2835_SPI_CLOCK_DIVIDER_1: bcm2835SPIClockDivider = 1;
#[doc = " \\brief bcm2835SPIClockDivider"]
#[doc = "Specifies the divider used to generate the SPI clock from the system clock."]
#[doc = "Figures below give the divider, clock period and clock frequency."]
#[doc = "Clock divided is based on nominal core clock rate of 250MHz on RPi1 and RPi2, and 400MHz on RPi3."]
#[doc = "It is reported that (contrary to the documentation) any even divider may used."]
#[doc = "The frequencies shown for each divider have been confirmed by measurement on RPi1 and RPi2."]
#[doc = "The system clock frequency on RPi3 is different, so the frequency you get from a given divider will be different."]
#[doc = "See comments in 'SPI Pins' for information about reliable SPI speeds."]
#[doc = "Note: it is possible to change the core clock rate of the RPi 3 back to 250MHz, by putting"]
#[doc = "\\code"]
#[doc = "core_freq=250"]
#[doc = "\\endcode"]
#[doc = "in the config.txt"]
pub type bcm2835SPIClockDivider = ::std::os::raw::c_uint;
#[doc = "< 2500 = 10us = 100 kHz"]
pub const bcm2835I2CClockDivider_BCM2835_I2C_CLOCK_DIVIDER_2500: bcm2835I2CClockDivider = 2500;
#[doc = "< 622 = 2.504us = 399.3610 kHz"]
pub const bcm2835I2CClockDivider_BCM2835_I2C_CLOCK_DIVIDER_626: bcm2835I2CClockDivider = 626;
#[doc = "< 150 = 60ns = 1.666 MHz (default at reset)"]
pub const bcm2835I2CClockDivider_BCM2835_I2C_CLOCK_DIVIDER_150: bcm2835I2CClockDivider = 150;
#[doc = "< 148 = 59ns = 1.689 MHz"]
pub const bcm2835I2CClockDivider_BCM2835_I2C_CLOCK_DIVIDER_148: bcm2835I2CClockDivider = 148;
#[doc = " \\brief bcm2835I2CClockDivider"]
#[doc = "Specifies the divider used to generate the I2C clock from the system clock."]
#[doc = "Clock divided is based on nominal base clock rate of 250MHz"]
pub type bcm2835I2CClockDivider = ::std::os::raw::c_uint;
#[doc = "< Success"]
pub const bcm2835I2CReasonCodes_BCM2835_I2C_REASON_OK: bcm2835I2CReasonCodes = 0;
#[doc = "< Received a NACK"]
pub const bcm2835I2CReasonCodes_BCM2835_I2C_REASON_ERROR_NACK: bcm2835I2CReasonCodes = 1;
#[doc = "< Received Clock Stretch Timeout"]
pub const bcm2835I2CReasonCodes_BCM2835_I2C_REASON_ERROR_CLKT: bcm2835I2CReasonCodes = 2;
#[doc = "< Not all data is sent / received"]
pub const bcm2835I2CReasonCodes_BCM2835_I2C_REASON_ERROR_DATA: bcm2835I2CReasonCodes = 4;
#[doc = " \\brief bcm2835I2CReasonCodes"]
#[doc = "Specifies the reason codes for the bcm2835_i2c_write and bcm2835_i2c_read functions."]
pub type bcm2835I2CReasonCodes = ::std::os::raw::c_uint;
#[doc = "< 2048 = 9.375kHz"]
pub const bcm2835PWMClockDivider_BCM2835_PWM_CLOCK_DIVIDER_2048: bcm2835PWMClockDivider = 2048;
#[doc = "< 1024 = 18.75kHz"]
pub const bcm2835PWMClockDivider_BCM2835_PWM_CLOCK_DIVIDER_1024: bcm2835PWMClockDivider = 1024;
#[doc = "< 512 = 37.5kHz"]
pub const bcm2835PWMClockDivider_BCM2835_PWM_CLOCK_DIVIDER_512: bcm2835PWMClockDivider = 512;
#[doc = "< 256 = 75kHz"]
pub const bcm2835PWMClockDivider_BCM2835_PWM_CLOCK_DIVIDER_256: bcm2835PWMClockDivider = 256;
#[doc = "< 128 = 150kHz"]
pub const bcm2835PWMClockDivider_BCM2835_PWM_CLOCK_DIVIDER_128: bcm2835PWMClockDivider = 128;
#[doc = "< 64 = 300kHz"]
pub const bcm2835PWMClockDivider_BCM2835_PWM_CLOCK_DIVIDER_64: bcm2835PWMClockDivider = 64;
#[doc = "< 32 = 600.0kHz"]
pub const bcm2835PWMClockDivider_BCM2835_PWM_CLOCK_DIVIDER_32: bcm2835PWMClockDivider = 32;
#[doc = "< 16 = 1.2MHz"]
pub const bcm2835PWMClockDivider_BCM2835_PWM_CLOCK_DIVIDER_16: bcm2835PWMClockDivider = 16;
#[doc = "< 8 = 2.4MHz"]
pub const bcm2835PWMClockDivider_BCM2835_PWM_CLOCK_DIVIDER_8: bcm2835PWMClockDivider = 8;
#[doc = "< 4 = 4.8MHz"]
pub const bcm2835PWMClockDivider_BCM2835_PWM_CLOCK_DIVIDER_4: bcm2835PWMClockDivider = 4;
#[doc = "< 2 = 9.6MHz, fastest you can get"]
pub const bcm2835PWMClockDivider_BCM2835_PWM_CLOCK_DIVIDER_2: bcm2835PWMClockDivider = 2;
#[doc = "< 1 = 4.6875kHz, same as divider 4096"]
pub const bcm2835PWMClockDivider_BCM2835_PWM_CLOCK_DIVIDER_1: bcm2835PWMClockDivider = 1;
#[doc = " \\brief bcm2835PWMClockDivider"]
#[doc = "Specifies the divider used to generate the PWM clock from the system clock."]
#[doc = "Figures below give the divider, clock period and clock frequency."]
#[doc = "Clock divided is based on nominal PWM base clock rate of 19.2MHz"]
#[doc = "The frequencies shown for each divider have been confirmed by measurement"]
pub type bcm2835PWMClockDivider = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Initialise the library by opening /dev/mem (if you are root)"]
    #[doc = "or /dev/gpiomem (if you are not)"]
    #[doc = "and getting pointers to the"]
    #[doc = "internal memory for BCM 2835 device registers. You must call this (successfully)"]
    #[doc = "before calling any other"]
    #[doc = "functions in this library (except bcm2835_set_debug)."]
    #[doc = "If bcm2835_init() fails by returning 0,"]
    #[doc = "calling any other function may result in crashes or other failures."]
    #[doc = "If bcm2835_init() succeeds but you are not running as root, then only gpio operations"]
    #[doc = "are permitted, and calling any other functions may result in crashes or other failures. ."]
    #[doc = "Prints messages to stderr in case of errors."]
    #[doc = "\\return 1 if successful else 0"]
    pub fn bcm2835_init() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Close the library, deallocating any allocated memory and closing /dev/mem"]
    #[doc = "\\return 1 if successful else 0"]
    pub fn bcm2835_close() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Sets the debug level of the library."]
    #[doc = "A value of 1 prevents mapping to /dev/mem, and makes the library print out"]
    #[doc = "what it would do, rather than accessing the GPIO registers."]
    #[doc = "A value of 0, the default, causes normal operation."]
    #[doc = "Call this before calling bcm2835_init();"]
    #[doc = "\\param[in] debug The new debug level. 1 means debug"]
    pub fn bcm2835_set_debug(debug: u8);
}
extern "C" {
    #[doc = " Returns the version number of the library, same as BCM2835_VERSION"]
    #[doc = "\\return the current library version number"]
    pub fn bcm2835_version() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Gets the base of a register"]
    #[doc = "\\param[in] regbase You can use one of the common values BCM2835_REGBASE_*"]
    #[doc = "in \\ref bcm2835RegisterBase"]
    #[doc = "\\return the register base"]
    #[doc = "\\sa Physical Addresses"]
    pub fn bcm2835_regbase(regbase: u8) -> *mut u32;
}
extern "C" {
    #[doc = " Reads 32 bit value from a peripheral address WITH a memory barrier before and after each read."]
    #[doc = "This is safe, but slow.  The MB before protects this read from any in-flight reads that didn't"]
    #[doc = "use a MB.  The MB after protects subsequent reads from another peripheral."]
    #[doc = ""]
    #[doc = "\\param[in] paddr Physical address to read from. See BCM2835_GPIO_BASE etc."]
    #[doc = "\\return the value read from the 32 bit register"]
    #[doc = "\\sa Physical Addresses"]
    pub fn bcm2835_peri_read(paddr: *mut u32) -> u32;
}
extern "C" {
    #[doc = " Reads 32 bit value from a peripheral address WITHOUT the read barriers"]
    #[doc = "You should only use this when:"]
    #[doc = "o your code has previously called bcm2835_peri_read() for a register"]
    #[doc = "within the same peripheral, and no read or write to another peripheral has occurred since."]
    #[doc = "o your code has called bcm2835_memory_barrier() since the last access to ANOTHER peripheral."]
    #[doc = ""]
    #[doc = "\\param[in] paddr Physical address to read from. See BCM2835_GPIO_BASE etc."]
    #[doc = "\\return the value read from the 32 bit register"]
    #[doc = "\\sa Physical Addresses"]
    pub fn bcm2835_peri_read_nb(paddr: *mut u32) -> u32;
}
extern "C" {
    #[doc = " Writes 32 bit value from a peripheral address WITH a memory barrier before and after each write"]
    #[doc = "This is safe, but slow.  The MB before ensures that any in-flight write to another peripheral"]
    #[doc = "completes before this write is issued.  The MB after ensures that subsequent reads and writes"]
    #[doc = "to another peripheral will see the effect of this write."]
    #[doc = ""]
    #[doc = "This is a tricky optimization; if you aren't sure, use the barrier version."]
    #[doc = ""]
    #[doc = "\\param[in] paddr Physical address to read from. See BCM2835_GPIO_BASE etc."]
    #[doc = "\\param[in] value The 32 bit value to write"]
    #[doc = "\\sa Physical Addresses"]
    pub fn bcm2835_peri_write(paddr: *mut u32, value: u32);
}

extern "C" {
    #[doc = " Writes 32 bit value from a peripheral address without the write barrier"]
    #[doc = "You should only use this when:"]
    #[doc = "o your code has previously called bcm2835_peri_write() for a register"]
    #[doc = "within the same peripheral, and no other peripheral access has occurred since."]
    #[doc = "o your code has called bcm2835_memory_barrier() since the last access to ANOTHER peripheral."]
    #[doc = ""]
    #[doc = "This is a tricky optimization; if you aren't sure, use the barrier version."]
    #[doc = ""]
    #[doc = "\\param[in] paddr Physical address to read from. See BCM2835_GPIO_BASE etc."]
    #[doc = "\\param[in] value The 32 bit value to write"]
    #[doc = "\\sa Physical Addresses"]
    pub fn bcm2835_peri_write_nb(paddr: *mut u32, value: u32);
}

extern "C" {
    #[doc = " Alters a number of bits in a 32 peripheral regsiter."]
    #[doc = "It reads the current valu and then alters the bits defines as 1 in mask,"]
    #[doc = "according to the bit value in value."]
    #[doc = "All other bits that are 0 in the mask are unaffected."]
    #[doc = "Use this to alter a subset of the bits in a register."]
    #[doc = "Memory barriers are used.  Note that this is not atomic; an interrupt"]
    #[doc = "routine can cause unexpected results."]
    #[doc = "\\param[in] paddr Physical address to read from. See BCM2835_GPIO_BASE etc."]
    #[doc = "\\param[in] value The 32 bit value to write, masked in by mask."]
    #[doc = "\\param[in] mask Bitmask that defines the bits that will be altered in the register."]
    #[doc = "\\sa Physical Addresses"]
    pub fn bcm2835_peri_set_bits(paddr: *mut u32, value: u32, mask: u32);
}
extern "C" {
    #[doc = " Sets the Function Select register for the given pin, which configures"]
    #[doc = "the pin as Input, Output or one of the 6 alternate functions."]
    #[doc = "\\param[in] pin GPIO number, or one of RPI_GPIO_P1_* from \\ref RPiGPIOPin."]
    #[doc = "\\param[in] mode Mode to set the pin to, one of BCM2835_GPIO_FSEL_* from \\ref bcm2835FunctionSelect"]
    pub fn bcm2835_gpio_fsel(pin: u8, mode: u8);
}
extern "C" {
    #[doc = " Sets the specified pin output to"]
    #[doc = "HIGH."]
    #[doc = "\\param[in] pin GPIO number, or one of RPI_GPIO_P1_* from \\ref RPiGPIOPin."]
    #[doc = "\\sa bcm2835_gpio_write()"]
    pub fn bcm2835_gpio_set(pin: u8);
}
extern "C" {
    #[doc = " Sets the specified pin output to"]
    #[doc = "LOW."]
    #[doc = "\\param[in] pin GPIO number, or one of RPI_GPIO_P1_* from \\ref RPiGPIOPin."]
    #[doc = "\\sa bcm2835_gpio_write()"]
    pub fn bcm2835_gpio_clr(pin: u8);
}
extern "C" {
    #[doc = " Sets any of the first 32 GPIO output pins specified in the mask to"]
    #[doc = "HIGH."]
    #[doc = "\\param[in] mask Mask of pins to affect. Use eg: (1 << RPI_GPIO_P1_03) | (1 << RPI_GPIO_P1_05)"]
    #[doc = "\\sa bcm2835_gpio_write_multi()"]
    pub fn bcm2835_gpio_set_multi(mask: u32);
}
extern "C" {
    #[doc = " Sets any of the first 32 GPIO output pins specified in the mask to"]
    #[doc = "LOW."]
    #[doc = "\\param[in] mask Mask of pins to affect. Use eg: (1 << RPI_GPIO_P1_03) | (1 << RPI_GPIO_P1_05)"]
    #[doc = "\\sa bcm2835_gpio_write_multi()"]
    pub fn bcm2835_gpio_clr_multi(mask: u32);
}
extern "C" {
    #[doc = " Reads the current level on the specified"]
    #[doc = "pin and returns either HIGH or LOW. Works whether or not the pin"]
    #[doc = "is an input or an output."]
    #[doc = "\\param[in] pin GPIO number, or one of RPI_GPIO_P1_* from \\ref RPiGPIOPin."]
    #[doc = "\\return the current level  either HIGH or LOW"]
    pub fn bcm2835_gpio_lev(pin: u8) -> u8;
}
extern "C" {
    #[doc = " Event Detect Status."]
    #[doc = "Tests whether the specified pin has detected a level or edge"]
    #[doc = "as requested by bcm2835_gpio_ren(), bcm2835_gpio_fen(), bcm2835_gpio_hen(),"]
    #[doc = "bcm2835_gpio_len(), bcm2835_gpio_aren(), bcm2835_gpio_afen()."]
    #[doc = "Clear the flag for a given pin by calling bcm2835_gpio_set_eds(pin);"]
    #[doc = "\\param[in] pin GPIO number, or one of RPI_GPIO_P1_* from \\ref RPiGPIOPin."]
    #[doc = "\\return HIGH if the event detect status for the given pin is true."]
    pub fn bcm2835_gpio_eds(pin: u8) -> u8;
}
extern "C" {
    #[doc = " Same as bcm2835_gpio_eds() but checks if any of the pins specified in"]
    #[doc = "the mask have detected a level or edge."]
    #[doc = "\\param[in] mask Mask of pins to check. Use eg: (1 << RPI_GPIO_P1_03) | (1 << RPI_GPIO_P1_05)"]
    #[doc = "\\return Mask of pins HIGH if the event detect status for the given pin is true."]
    pub fn bcm2835_gpio_eds_multi(mask: u32) -> u32;
}
extern "C" {
    #[doc = " Sets the Event Detect Status register for a given pin to 1,"]
    #[doc = "which has the effect of clearing the flag. Use this afer seeing"]
    #[doc = "an Event Detect Status on the pin."]
    #[doc = "\\param[in] pin GPIO number, or one of RPI_GPIO_P1_* from \\ref RPiGPIOPin."]
    pub fn bcm2835_gpio_set_eds(pin: u8);
}
extern "C" {
    #[doc = " Same as bcm2835_gpio_set_eds() but clears the flag for any pin which"]
    #[doc = "is set in the mask."]
    #[doc = "\\param[in] mask Mask of pins to clear. Use eg: (1 << RPI_GPIO_P1_03) | (1 << RPI_GPIO_P1_05)"]
    pub fn bcm2835_gpio_set_eds_multi(mask: u32);
}
extern "C" {
    #[doc = " Enable Rising Edge Detect Enable for the specified pin."]
    #[doc = "When a rising edge is detected, sets the appropriate pin in Event Detect Status."]
    #[doc = "The GPRENn registers use"]
    #[doc = "synchronous edge detection. This means the input signal is sampled using the"]
    #[doc = "system clock and then it is looking for a ?011? pattern on the sampled signal. This"]
    #[doc = "has the effect of suppressing glitches."]
    #[doc = "\\param[in] pin GPIO number, or one of RPI_GPIO_P1_* from \\ref RPiGPIOPin."]
    pub fn bcm2835_gpio_ren(pin: u8);
}
extern "C" {
    #[doc = " Disable Rising Edge Detect Enable for the specified pin."]
    #[doc = "\\param[in] pin GPIO number, or one of RPI_GPIO_P1_* from \\ref RPiGPIOPin."]
    pub fn bcm2835_gpio_clr_ren(pin: u8);
}
extern "C" {
    #[doc = " Enable Falling Edge Detect Enable for the specified pin."]
    #[doc = "When a falling edge is detected, sets the appropriate pin in Event Detect Status."]
    #[doc = "The GPRENn registers use"]
    #[doc = "synchronous edge detection. This means the input signal is sampled using the"]
    #[doc = "system clock and then it is looking for a ?100? pattern on the sampled signal. This"]
    #[doc = "has the effect of suppressing glitches."]
    #[doc = "\\param[in] pin GPIO number, or one of RPI_GPIO_P1_* from \\ref RPiGPIOPin."]
    pub fn bcm2835_gpio_fen(pin: u8);
}
extern "C" {
    #[doc = " Disable Falling Edge Detect Enable for the specified pin."]
    #[doc = "\\param[in] pin GPIO number, or one of RPI_GPIO_P1_* from \\ref RPiGPIOPin."]
    pub fn bcm2835_gpio_clr_fen(pin: u8);
}
extern "C" {
    #[doc = " Enable High Detect Enable for the specified pin."]
    #[doc = "When a HIGH level is detected on the pin, sets the appropriate pin in Event Detect Status."]
    #[doc = "\\param[in] pin GPIO number, or one of RPI_GPIO_P1_* from \\ref RPiGPIOPin."]
    pub fn bcm2835_gpio_hen(pin: u8);
}
extern "C" {
    #[doc = " Disable High Detect Enable for the specified pin."]
    #[doc = "\\param[in] pin GPIO number, or one of RPI_GPIO_P1_* from \\ref RPiGPIOPin."]
    pub fn bcm2835_gpio_clr_hen(pin: u8);
}
extern "C" {
    #[doc = " Enable Low Detect Enable for the specified pin."]
    #[doc = "When a LOW level is detected on the pin, sets the appropriate pin in Event Detect Status."]
    #[doc = "\\param[in] pin GPIO number, or one of RPI_GPIO_P1_* from \\ref RPiGPIOPin."]
    pub fn bcm2835_gpio_len(pin: u8);
}
extern "C" {
    #[doc = " Disable Low Detect Enable for the specified pin."]
    #[doc = "\\param[in] pin GPIO number, or one of RPI_GPIO_P1_* from \\ref RPiGPIOPin."]
    pub fn bcm2835_gpio_clr_len(pin: u8);
}
extern "C" {
    #[doc = " Enable Asynchronous Rising Edge Detect Enable for the specified pin."]
    #[doc = "When a rising edge is detected, sets the appropriate pin in Event Detect Status."]
    #[doc = "Asynchronous means the incoming signal is not sampled by the system clock. As such"]
    #[doc = "rising edges of very short duration can be detected."]
    #[doc = "\\param[in] pin GPIO number, or one of RPI_GPIO_P1_* from \\ref RPiGPIOPin."]
    pub fn bcm2835_gpio_aren(pin: u8);
}
extern "C" {
    #[doc = " Disable Asynchronous Rising Edge Detect Enable for the specified pin."]
    #[doc = "\\param[in] pin GPIO number, or one of RPI_GPIO_P1_* from \\ref RPiGPIOPin."]
    pub fn bcm2835_gpio_clr_aren(pin: u8);
}
extern "C" {
    #[doc = " Enable Asynchronous Falling Edge Detect Enable for the specified pin."]
    #[doc = "When a falling edge is detected, sets the appropriate pin in Event Detect Status."]
    #[doc = "Asynchronous means the incoming signal is not sampled by the system clock. As such"]
    #[doc = "falling edges of very short duration can be detected."]
    #[doc = "\\param[in] pin GPIO number, or one of RPI_GPIO_P1_* from \\ref RPiGPIOPin."]
    pub fn bcm2835_gpio_afen(pin: u8);
}
extern "C" {
    #[doc = " Disable Asynchronous Falling Edge Detect Enable for the specified pin."]
    #[doc = "\\param[in] pin GPIO number, or one of RPI_GPIO_P1_* from \\ref RPiGPIOPin."]
    pub fn bcm2835_gpio_clr_afen(pin: u8);
}
extern "C" {
    #[doc = " Sets the Pull-up/down register for the given pin. This is"]
    #[doc = "used with bcm2835_gpio_pudclk() to set the  Pull-up/down resistor for the given pin."]
    #[doc = "However, it is usually more convenient to use bcm2835_gpio_set_pud()."]
    #[doc = "\\param[in] pud The desired Pull-up/down mode. One of BCM2835_GPIO_PUD_* from bcm2835PUDControl"]
    #[doc = "On the RPI 4, although this function and bcm2835_gpio_pudclk() are supported for backward"]
    #[doc = "compatibility, new code should always use bcm2835_gpio_set_pud()."]
    #[doc = "\\sa bcm2835_gpio_set_pud()"]
    pub fn bcm2835_gpio_pud(pud: u8);
}
extern "C" {
    #[doc = " Clocks the Pull-up/down value set earlier by bcm2835_gpio_pud() into the pin."]
    #[doc = "\\param[in] pin GPIO number, or one of RPI_GPIO_P1_* from \\ref RPiGPIOPin."]
    #[doc = "\\param[in] on HIGH to clock the value from bcm2835_gpio_pud() into the pin."]
    #[doc = "LOW to remove the clock."]
    #[doc = ""]
    #[doc = "On the RPI 4, although this function and bcm2835_gpio_pud() are supported for backward"]
    #[doc = "compatibility, new code should always use bcm2835_gpio_set_pud()."]
    #[doc = ""]
    #[doc = "\\sa bcm2835_gpio_set_pud()"]
    pub fn bcm2835_gpio_pudclk(pin: u8, on: u8);
}
extern "C" {
    #[doc = " Reads and returns the Pad Control for the given GPIO group."]
    #[doc = "Caution: requires root access."]
    #[doc = "\\param[in] group The GPIO pad group number, one of BCM2835_PAD_GROUP_GPIO_*"]
    #[doc = "\\return Mask of bits from BCM2835_PAD_* from \\ref bcm2835PadGroup"]
    pub fn bcm2835_gpio_pad(group: u8) -> u32;
}
extern "C" {
    #[doc = " Sets the Pad Control for the given GPIO group."]
    #[doc = "Caution: requires root access."]
    #[doc = "\\param[in] group The GPIO pad group number, one of BCM2835_PAD_GROUP_GPIO_*"]
    #[doc = "\\param[in] control Mask of bits from BCM2835_PAD_* from \\ref bcm2835PadGroup. Note"]
    #[doc = "that it is not necessary to include BCM2835_PAD_PASSWRD in the mask as this"]
    #[doc = "is automatically included."]
    pub fn bcm2835_gpio_set_pad(group: u8, control: u32);
}
extern "C" {
    #[doc = " Delays for the specified number of milliseconds."]
    #[doc = "Uses nanosleep(), and therefore does not use CPU until the time is up."]
    #[doc = "However, you are at the mercy of nanosleep(). From the manual for nanosleep():"]
    #[doc = "If the interval specified in req is not an exact multiple of the granularity"]
    #[doc = "underlying  clock  (see  time(7)),  then the interval will be"]
    #[doc = "rounded up to the next multiple. Furthermore, after the sleep completes,"]
    #[doc = "there may still be a delay before the CPU becomes free to once"]
    #[doc = "again execute the calling thread."]
    #[doc = "\\param[in] millis Delay in milliseconds"]
    pub fn bcm2835_delay(millis: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " Delays for the specified number of microseconds."]
    #[doc = "Uses a combination of nanosleep() and a busy wait loop on the BCM2835 system timers,"]
    #[doc = "However, you are at the mercy of nanosleep(). From the manual for nanosleep():"]
    #[doc = "If the interval specified in req is not an exact multiple of the granularity"]
    #[doc = "underlying  clock  (see  time(7)),  then the interval will be"]
    #[doc = "rounded up to the next multiple. Furthermore, after the sleep completes,"]
    #[doc = "there may still be a delay before the CPU becomes free to once"]
    #[doc = "again execute the calling thread."]
    #[doc = "For times less than about 450 microseconds, uses a busy wait on the System Timer."]
    #[doc = "It is reported that a delay of 0 microseconds on RaspberryPi will in fact"]
    #[doc = "result in a delay of about 80 microseconds. Your mileage may vary."]
    #[doc = "\\param[in] micros Delay in microseconds"]
    pub fn bcm2835_delayMicroseconds(micros: u64);
}
extern "C" {
    #[doc = " Sets the output state of the specified pin"]
    #[doc = "\\param[in] pin GPIO number, or one of RPI_GPIO_P1_* from \\ref RPiGPIOPin."]
    #[doc = "\\param[in] on HIGH sets the output to HIGH and LOW to LOW."]
    pub fn bcm2835_gpio_write(pin: u8, on: u8);
}
extern "C" {
    #[doc = " Sets any of the first 32 GPIO output pins specified in the mask to the state given by on"]
    #[doc = "\\param[in] mask Mask of pins to affect. Use eg: (1 << RPI_GPIO_P1_03) | (1 << RPI_GPIO_P1_05)"]
    #[doc = "\\param[in] on HIGH sets the output to HIGH and LOW to LOW."]
    pub fn bcm2835_gpio_write_multi(mask: u32, on: u8);
}
extern "C" {
    #[doc = " Sets the first 32 GPIO output pins specified in the mask to the value given by value"]
    #[doc = "\\param[in] value values required for each bit masked in by mask, eg: (1 << RPI_GPIO_P1_03) | (1 << RPI_GPIO_P1_05)"]
    #[doc = "\\param[in] mask Mask of pins to affect. Use eg: (1 << RPI_GPIO_P1_03) | (1 << RPI_GPIO_P1_05)"]
    pub fn bcm2835_gpio_write_mask(value: u32, mask: u32);
}
extern "C" {
    #[doc = " Sets the Pull-up/down mode for the specified pin. This is more convenient than"]
    #[doc = "clocking the mode in with bcm2835_gpio_pud() and bcm2835_gpio_pudclk()."]
    #[doc = "\\param[in] pin GPIO number, or one of RPI_GPIO_P1_* from \\ref RPiGPIOPin."]
    #[doc = "\\param[in] pud The desired Pull-up/down mode. One of BCM2835_GPIO_PUD_* from bcm2835PUDControl"]
    pub fn bcm2835_gpio_set_pud(pin: u8, pud: u8);
}
extern "C" {
    #[doc = " On the BCM2711 based RPI 4, gets the current Pull-up/down mode for the specified pin."]
    #[doc = "Returns one of BCM2835_GPIO_PUD_* from bcm2835PUDControl."]
    #[doc = "On earlier RPI versions not based on the BCM2711, returns BCM2835_GPIO_PUD_ERROR"]
    #[doc = "\\param[in] pin GPIO number, or one of RPI_GPIO_P1_* from \\ref RPiGPIOPin."]
    pub fn bcm2835_gpio_get_pud(pin: u8) -> u8;
}
extern "C" {
    #[doc = " Start SPI operations."]
    #[doc = "Forces RPi SPI0 pins P1-19 (MOSI), P1-21 (MISO), P1-23 (CLK), P1-24 (CE0) and P1-26 (CE1)"]
    #[doc = "to alternate function ALT0, which enables those pins for SPI interface."]
    #[doc = "You should call bcm2835_spi_end() when all SPI funcitons are complete to return the pins to"]
    #[doc = "their default functions."]
    #[doc = "\\sa  bcm2835_spi_end()"]
    #[doc = "\\return 1 if successful, 0 otherwise (perhaps because you are not running as root)"]
    pub fn bcm2835_spi_begin() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " End SPI operations."]
    #[doc = "SPI0 pins P1-19 (MOSI), P1-21 (MISO), P1-23 (CLK), P1-24 (CE0) and P1-26 (CE1)"]
    #[doc = "are returned to their default INPUT behaviour."]
    pub fn bcm2835_spi_end();
}
extern "C" {
    #[doc = " Sets the SPI bit order"]
    #[doc = "Set the bit order to be used for transmit and receive. The bcm2835 SPI0 only supports BCM2835_SPI_BIT_ORDER_MSB,"]
    #[doc = "so if you select BCM2835_SPI_BIT_ORDER_LSB, the bytes will be reversed in software."]
    #[doc = "The library defaults to BCM2835_SPI_BIT_ORDER_MSB."]
    #[doc = "\\param[in] order The desired bit order, one of BCM2835_SPI_BIT_ORDER_*,"]
    #[doc = "see \\ref bcm2835SPIBitOrder"]
    pub fn bcm2835_spi_setBitOrder(order: u8);
}
extern "C" {
    #[doc = " Sets the SPI clock divider and therefore the"]
    #[doc = "SPI clock speed."]
    #[doc = "\\param[in] divider The desired SPI clock divider, one of BCM2835_SPI_CLOCK_DIVIDER_*,"]
    #[doc = "see \\ref bcm2835SPIClockDivider"]
    pub fn bcm2835_spi_setClockDivider(divider: u16);
}
extern "C" {
    #[doc = " Sets the SPI clock divider by converting the speed parameter to"]
    #[doc = "the equivalent SPI clock divider. ( see \\sa bcm2835_spi_setClockDivider)"]
    #[doc = "\\param[in] speed_hz The desired SPI clock speed in Hz"]
    pub fn bcm2835_spi_set_speed_hz(speed_hz: u32);
}
extern "C" {
    #[doc = " Sets the SPI data mode"]
    #[doc = "Sets the clock polariy and phase"]
    #[doc = "\\param[in] mode The desired data mode, one of BCM2835_SPI_MODE*,"]
    #[doc = "see \\ref bcm2835SPIMode"]
    pub fn bcm2835_spi_setDataMode(mode: u8);
}
extern "C" {
    #[doc = " Sets the chip select pin(s)"]
    #[doc = "When an bcm2835_spi_transfer() is made, the selected pin(s) will be asserted during the"]
    #[doc = "transfer."]
    #[doc = "\\param[in] cs Specifies the CS pins(s) that are used to activate the desired slave."]
    #[doc = "One of BCM2835_SPI_CS*, see \\ref bcm2835SPIChipSelect"]
    pub fn bcm2835_spi_chipSelect(cs: u8);
}
extern "C" {
    #[doc = " Sets the chip select pin polarity for a given pin"]
    #[doc = "When an bcm2835_spi_transfer() occurs, the currently selected chip select pin(s)"]
    #[doc = "will be asserted to the"]
    #[doc = "value given by active. When transfers are not happening, the chip select pin(s)"]
    #[doc = "return to the complement (inactive) value."]
    #[doc = "\\param[in] cs The chip select pin to affect"]
    #[doc = "\\param[in] active Whether the chip select pin is to be active HIGH"]
    pub fn bcm2835_spi_setChipSelectPolarity(cs: u8, active: u8);
}
extern "C" {
    #[doc = " Transfers one byte to and from the currently selected SPI slave."]
    #[doc = "Asserts the currently selected CS pins (as previously set by bcm2835_spi_chipSelect)"]
    #[doc = "during the transfer."]
    #[doc = "Clocks the 8 bit value out on MOSI, and simultaneously clocks in data from MISO."]
    #[doc = "Returns the read data byte from the slave."]
    #[doc = "Uses polled transfer as per section 10.6.1 of the BCM 2835 ARM Peripherls manual"]
    #[doc = "\\param[in] value The 8 bit data byte to write to MOSI"]
    #[doc = "\\return The 8 bit byte simultaneously read from  MISO"]
    #[doc = "\\sa bcm2835_spi_transfern()"]
    pub fn bcm2835_spi_transfer(value: u8) -> u8;
}
extern "C" {
    #[doc = " Transfers any number of bytes to and from the currently selected SPI slave."]
    #[doc = "Asserts the currently selected CS pins (as previously set by bcm2835_spi_chipSelect)"]
    #[doc = "during the transfer."]
    #[doc = "Clocks the len 8 bit bytes out on MOSI, and simultaneously clocks in data from MISO."]
    #[doc = "The data read read from the slave is placed into rbuf. rbuf must be at least len bytes long"]
    #[doc = "Uses polled transfer as per section 10.6.1 of the BCM 2835 ARM Peripherls manual"]
    #[doc = "\\param[in] tbuf Buffer of bytes to send."]
    #[doc = "\\param[out] rbuf Received bytes will by put in this buffer"]
    #[doc = "\\param[in] len Number of bytes in the tbuf buffer, and the number of bytes to send/received"]
    #[doc = "\\sa bcm2835_spi_transfer()"]
    pub fn bcm2835_spi_transfernb(
        tbuf: *mut ::std::os::raw::c_char,
        rbuf: *mut ::std::os::raw::c_char,
        len: u32,
    );
}
extern "C" {
    #[doc = " Transfers any number of bytes to and from the currently selected SPI slave"]
    #[doc = "using bcm2835_spi_transfernb."]
    #[doc = "The returned data from the slave replaces the transmitted data in the buffer."]
    #[doc = "\\param[in,out] buf Buffer of bytes to send. Received bytes will replace the contents"]
    #[doc = "\\param[in] len Number of bytes int eh buffer, and the number of bytes to send/received"]
    #[doc = "\\sa bcm2835_spi_transfer()"]
    pub fn bcm2835_spi_transfern(buf: *mut ::std::os::raw::c_char, len: u32);
}
extern "C" {
    #[doc = " Transfers any number of bytes to the currently selected SPI slave."]
    #[doc = "Asserts the currently selected CS pins (as previously set by bcm2835_spi_chipSelect)"]
    #[doc = "during the transfer."]
    #[doc = "\\param[in] buf Buffer of bytes to send."]
    #[doc = "\\param[in] len Number of bytes in the buf buffer, and the number of bytes to send"]
    pub fn bcm2835_spi_writenb(buf: *const ::std::os::raw::c_char, len: u32);
}
extern "C" {
    #[doc = " Transfers half-word to the currently selected SPI slave."]
    #[doc = "Asserts the currently selected CS pins (as previously set by bcm2835_spi_chipSelect)"]
    #[doc = "during the transfer."]
    #[doc = "Clocks the 8 bit value out on MOSI, and simultaneously clocks in data from MISO."]
    #[doc = "Uses polled transfer as per section 10.6.1 of the BCM 2835 ARM Peripherls manual"]
    #[doc = "\\param[in] data The 8 bit data byte to write to MOSI"]
    #[doc = "\\sa bcm2835_spi_writenb()"]
    pub fn bcm2835_spi_write(data: u16);
}
extern "C" {
    #[doc = " Start AUX SPI operations."]
    #[doc = "Forces RPi AUX SPI pins P1-38 (MOSI), P1-38 (MISO), P1-40 (CLK) and P1-36 (CE2)"]
    #[doc = "to alternate function ALT4, which enables those pins for SPI interface."]
    #[doc = "\\return 1 if successful, 0 otherwise (perhaps because you are not running as root)"]
    pub fn bcm2835_aux_spi_begin() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " End AUX SPI operations."]
    #[doc = "SPI1 pins P1-38 (MOSI), P1-38 (MISO), P1-40 (CLK) and P1-36 (CE2)"]
    #[doc = "are returned to their default INPUT behaviour."]
    pub fn bcm2835_aux_spi_end();
}
extern "C" {
    #[doc = " Sets the AUX SPI clock divider and therefore the AUX SPI clock speed."]
    #[doc = "\\param[in] divider The desired AUX SPI clock divider."]
    pub fn bcm2835_aux_spi_setClockDivider(divider: u16);
}
extern "C" {
    #[doc = " Calculates the input for \\sa bcm2835_aux_spi_setClockDivider"]
    #[doc = " @param speed_hz A value between \\sa BCM2835_AUX_SPI_CLOCK_MIN and \\sa BCM2835_AUX_SPI_CLOCK_MAX"]
    #[doc = " @return Input for \\sa bcm2835_aux_spi_setClockDivider"]
    pub fn bcm2835_aux_spi_CalcClockDivider(speed_hz: u32) -> u16;
}
extern "C" {
    #[doc = " Transfers half-word to the AUX SPI slave."]
    #[doc = "Asserts the currently selected CS pins during the transfer."]
    #[doc = "\\param[in] data The 8 bit data byte to write to MOSI"]
    #[doc = "\\return The 16 bit byte simultaneously read from  MISO"]
    #[doc = "\\sa bcm2835_spi_transfern()"]
    pub fn bcm2835_aux_spi_write(data: u16);
}
extern "C" {
    #[doc = " Transfers any number of bytes to the AUX SPI slave."]
    #[doc = "Asserts the CE2 pin during the transfer."]
    #[doc = "\\param[in] buf Buffer of bytes to send."]
    #[doc = "\\param[in] len Number of bytes in the tbuf buffer, and the number of bytes to send"]
    pub fn bcm2835_aux_spi_writenb(buf: *const ::std::os::raw::c_char, len: u32);
}
extern "C" {
    #[doc = " Transfers any number of bytes to and from the AUX SPI slave"]
    #[doc = "using bcm2835_aux_spi_transfernb."]
    #[doc = "The returned data from the slave replaces the transmitted data in the buffer."]
    #[doc = "\\param[in,out] buf Buffer of bytes to send. Received bytes will replace the contents"]
    #[doc = "\\param[in] len Number of bytes in the buffer, and the number of bytes to send/received"]
    #[doc = "\\sa bcm2835_aux_spi_transfer()"]
    pub fn bcm2835_aux_spi_transfern(buf: *mut ::std::os::raw::c_char, len: u32);
}
extern "C" {
    #[doc = " Transfers any number of bytes to and from the AUX SPI slave."]
    #[doc = "Asserts the CE2 pin during the transfer."]
    #[doc = "Clocks the len 8 bit bytes out on MOSI, and simultaneously clocks in data from MISO."]
    #[doc = "The data read read from the slave is placed into rbuf. rbuf must be at least len bytes long"]
    #[doc = "\\param[in] tbuf Buffer of bytes to send."]
    #[doc = "\\param[out] rbuf Received bytes will by put in this buffer"]
    #[doc = "\\param[in] len Number of bytes in the tbuf buffer, and the number of bytes to send/received"]
    pub fn bcm2835_aux_spi_transfernb(
        tbuf: *const ::std::os::raw::c_char,
        rbuf: *mut ::std::os::raw::c_char,
        len: u32,
    );
}
extern "C" {
    #[doc = " Transfers one byte to and from the AUX SPI slave."]
    #[doc = "Clocks the 8 bit value out on MOSI, and simultaneously clocks in data from MISO."]
    #[doc = "Returns the read data byte from the slave."]
    #[doc = "\\param[in] value The 8 bit data byte to write to MOSI"]
    #[doc = "\\return The 8 bit byte simultaneously read from MISO"]
    #[doc = "\\sa bcm2835_aux_spi_transfern()"]
    pub fn bcm2835_aux_spi_transfer(value: u8) -> u8;
}
extern "C" {
    #[doc = " Start I2C operations."]
    #[doc = "Forces RPi I2C pins P1-03 (SDA) and P1-05 (SCL)"]
    #[doc = "to alternate function ALT0, which enables those pins for I2C interface."]
    #[doc = "You should call bcm2835_i2c_end() when all I2C functions are complete to return the pins to"]
    #[doc = "their default functions"]
    #[doc = "\\return 1 if successful, 0 otherwise (perhaps because you are not running as root)"]
    #[doc = "\\sa  bcm2835_i2c_end()"]
    pub fn bcm2835_i2c_begin() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " End I2C operations."]
    #[doc = "I2C pins P1-03 (SDA) and P1-05 (SCL)"]
    #[doc = "are returned to their default INPUT behaviour."]
    pub fn bcm2835_i2c_end();
}
extern "C" {
    #[doc = " Sets the I2C slave address."]
    #[doc = "\\param[in] addr The I2C slave address."]
    pub fn bcm2835_i2c_setSlaveAddress(addr: u8);
}
extern "C" {
    #[doc = " Sets the I2C clock divider and therefore the I2C clock speed."]
    #[doc = "\\param[in] divider The desired I2C clock divider, one of BCM2835_I2C_CLOCK_DIVIDER_*,"]
    #[doc = "see \\ref bcm2835I2CClockDivider"]
    pub fn bcm2835_i2c_setClockDivider(divider: u16);
}
extern "C" {
    #[doc = " Sets the I2C clock divider by converting the baudrate parameter to"]
    #[doc = "the equivalent I2C clock divider. ( see \\sa bcm2835_i2c_setClockDivider)"]
    #[doc = "For the I2C standard 100khz you would set baudrate to 100000"]
    #[doc = "The use of baudrate corresponds to its use in the I2C kernel device"]
    #[doc = "driver. (Of course, bcm2835 has nothing to do with the kernel driver)"]
    pub fn bcm2835_i2c_set_baudrate(baudrate: u32);
}
extern "C" {
    #[doc = " Transfers any number of bytes to the currently selected I2C slave."]
    #[doc = "(as previously set by \\sa bcm2835_i2c_setSlaveAddress)"]
    #[doc = "\\param[in] buf Buffer of bytes to send."]
    #[doc = "\\param[in] len Number of bytes in the buf buffer, and the number of bytes to send."]
    #[doc = "\\return reason see \\ref bcm2835I2CReasonCodes"]
    pub fn bcm2835_i2c_write(buf: *const ::std::os::raw::c_char, len: u32) -> u8;
}
extern "C" {
    #[doc = " Transfers any number of bytes from the currently selected I2C slave."]
    #[doc = "(as previously set by \\sa bcm2835_i2c_setSlaveAddress)"]
    #[doc = "\\param[in] buf Buffer of bytes to receive."]
    #[doc = "\\param[in] len Number of bytes in the buf buffer, and the number of bytes to received."]
    #[doc = "\\return reason see \\ref bcm2835I2CReasonCodes"]
    pub fn bcm2835_i2c_read(buf: *mut ::std::os::raw::c_char, len: u32) -> u8;
}
extern "C" {
    #[doc = " Allows reading from I2C slaves that require a repeated start (without any prior stop)"]
    #[doc = "to read after the required slave register has been set. For example, the popular"]
    #[doc = "MPL3115A2 pressure and temperature sensor. Note that your device must support or"]
    #[doc = "require this mode. If your device does not require this mode then the standard"]
    #[doc = "combined:"]
    #[doc = "\\sa bcm2835_i2c_write"]
    #[doc = "\\sa bcm2835_i2c_read"]
    #[doc = "are a better choice."]
    #[doc = "Will read from the slave previously set by \\sa bcm2835_i2c_setSlaveAddress"]
    #[doc = "\\param[in] regaddr Buffer containing the slave register you wish to read from."]
    #[doc = "\\param[in] buf Buffer of bytes to receive."]
    #[doc = "\\param[in] len Number of bytes in the buf buffer, and the number of bytes to received."]
    #[doc = "\\return reason see \\ref bcm2835I2CReasonCodes"]
    pub fn bcm2835_i2c_read_register_rs(
        regaddr: *mut ::std::os::raw::c_char,
        buf: *mut ::std::os::raw::c_char,
        len: u32,
    ) -> u8;
}
extern "C" {
    #[doc = " Allows sending an arbitrary number of bytes to I2C slaves before issuing a repeated"]
    #[doc = "start (with no prior stop) and reading a response."]
    #[doc = "Necessary for devices that require such behavior, such as the MLX90620."]
    #[doc = "Will write to and read from the slave previously set by \\sa bcm2835_i2c_setSlaveAddress"]
    #[doc = "\\param[in] cmds Buffer containing the bytes to send before the repeated start condition."]
    #[doc = "\\param[in] cmds_len Number of bytes to send from cmds buffer"]
    #[doc = "\\param[in] buf Buffer of bytes to receive."]
    #[doc = "\\param[in] buf_len Number of bytes to receive in the buf buffer."]
    #[doc = "\\return reason see \\ref bcm2835I2CReasonCodes"]
    pub fn bcm2835_i2c_write_read_rs(
        cmds: *mut ::std::os::raw::c_char,
        cmds_len: u32,
        buf: *mut ::std::os::raw::c_char,
        buf_len: u32,
    ) -> u8;
}
extern "C" {
    #[doc = " Read the System Timer Counter register."]
    #[doc = "\\return the value read from the System Timer Counter Lower 32 bits register"]
    pub fn bcm2835_st_read() -> u64;
}
extern "C" {
    #[doc = " Delays for the specified number of microseconds with offset."]
    #[doc = "\\param[in] offset_micros Offset in microseconds"]
    #[doc = "\\param[in] micros Delay in microseconds"]
    pub fn bcm2835_st_delay(offset_micros: u64, micros: u64);
}
extern "C" {
    #[doc = " Sets the PWM clock divisor,"]
    #[doc = "to control the basic PWM pulse widths."]
    #[doc = "\\param[in] divisor Divides the basic 19.2MHz PWM clock. You can use one of the common"]
    #[doc = "values BCM2835_PWM_CLOCK_DIVIDER_* in \\ref bcm2835PWMClockDivider"]
    pub fn bcm2835_pwm_set_clock(divisor: u32);
}
extern "C" {
    #[doc = " Sets the mode of the given PWM channel,"]
    #[doc = "allowing you to control the PWM mode and enable/disable that channel"]
    #[doc = "\\param[in] channel The PWM channel. 0 or 1."]
    #[doc = "\\param[in] markspace Set true if you want Mark-Space mode. 0 for Balanced mode."]
    #[doc = "\\param[in] enabled Set true to enable this channel and produce PWM pulses."]
    pub fn bcm2835_pwm_set_mode(channel: u8, markspace: u8, enabled: u8);
}
extern "C" {
    #[doc = " Sets the maximum range of the PWM output."]
    #[doc = "The data value can vary between 0 and this range to control PWM output"]
    #[doc = "\\param[in] channel The PWM channel. 0 or 1."]
    #[doc = "\\param[in] range The maximum value permitted for DATA."]
    pub fn bcm2835_pwm_set_range(channel: u8, range: u32);
}
extern "C" {
    #[doc = " Sets the PWM pulse ratio to emit to DATA/RANGE,"]
    #[doc = "where RANGE is set by bcm2835_pwm_set_range()."]
    #[doc = "\\param[in] channel The PWM channel. 0 or 1."]
    #[doc = "\\param[in] data Controls the PWM output ratio as a fraction of the range."]
    #[doc = "Can vary from 0 to RANGE."]
    pub fn bcm2835_pwm_set_data(channel: u8, data: u32);
}
